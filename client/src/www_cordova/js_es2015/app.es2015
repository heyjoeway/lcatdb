let isWebsite = false;

class OfflineEvent {
    constructor(obj) {
        obj = obj || {};
        this.type = obj.type || "OfflineEvent";
        this.data = obj.data || {};
        this.id = obj.id || this.randomId();
        this.autoSubmit = obj.autoSubmit || true;
        this.status = "pending";
        this.failures = 0;
        this.priority = 0; // Higher priority = processes sooner TODO
        /* 
         * Available states are:
         * - hold: Event is being modified or held in some form, do not submit
         * - pending: Waiting to be submitted
         * - success: Already succeeded (event should be deleted in this case)
         * - idConflict: Event has already been processed by server (same as success)
         * - failure: Generic failure, allow user to manually retry
         * 
         * Other states can be provided and managed by subclasses
         */
    }

    toObj() {
        return {
            "type": this.type,
            "data": this.data,
            "id": this.id,
            "autoSubmit": this.autoSubmit,
            "status": this.status,
            "priority": this.priority
        }
    }

    randomId() {
        return Math.random().toString().substr(2);
    }

    submit(callback) {
        console.log("Please override this function.");
        callback({ "success": "true" });
    }
}

class OfflineEventPost extends OfflineEvent {
    constructor(data) {
        super({
            "type": "OfflineEventPost",
            "data": data
        });

        // data = {
        //     "formUrl": "form url",
        //     "formData": "form data"
        // }
    }

    submit(callback) {
        $.post(this.data.formUrl, this.data.formData, (data, status) => {
            console.log(status);
            if (status == 'success') {
                this.status = success;
                callback({
                    success: true
                });
                this.response = {
                    data: data,
                    status: status
                };
            } else { 
                this.status = 'failure';
                this.failures++;
                callback({
                    success: false
                });
            }
        }).fail(() => {
            this.status = 'failure';
            this.failures++;
            callback({
                success: false
            });
        });
    }
}

class OfflineEventQueue {
    constructor(name) {
        this.events = [];
        this.name = name || 'default';
        this.loadEvents();
    }

    autoSubmit() {
        this.events.forEach((event) => {
            if (!event.autoSubmit) return;
            
            if (event.status == 'pending') {
                startInputBlock();
                event.submit((result) => {
                    if (result.success) return this.removeEvent(event);
                    else this.saveEvents();                    
                    finishInputBlock();
                });
            }

            
        });

    }

    removeEvent(event) {
        let eventIndex = this.events.indexOf(event);
        if (eventIndex > -1)
            this.events.splice(eventIndex, 1);
        this.saveEvents();
    }

    addEvent(event) {
        this.events.push(event);
        this.saveEvents();        
    }

    toArray() {
        let objArray = [];
        this.events.forEach((event) => {
            objArray.push(event.toObj());
        });
        return objArray;
    }

    saveEvents() {
        let key = `offlineEvents.${this.name}`;
        localStorage[key] = JSON.stringify(this.toArray());
    }

    loadEvents() {
        let key = `offlineEvents.${this.name}`;
        let eventsString = localStorage[key];

        if ((typeof eventsString == 'undefined') || (eventsString == ''))
            return;

        eventsArray = JSON.parse(eventsString);
        eventsArray.forEach((eventData) => {
            this.events.push(new OfflineEventPost(eventData)); // TODO
        });
    }
}

$(() => {
    window.offlineEventQueue = new OfflineEventQueue();
});
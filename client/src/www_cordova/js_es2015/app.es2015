let isWebsite = false;

class OfflineEvent {
    constructor(obj) {
        obj = obj || {};
        this.type = obj.type || "OfflineEvent";
        this.name = obj.name || "Unknown";
        this.data = obj.data || {};
        this.timeCreated = obj.timeCreated || (new Date()).getTime();
        this.id = obj.id || this.randomId();
        this.autoSubmit = obj.autoSubmit || true;
        this.status = "pending";
        this.failures = 0;
        this.priority = 0; // Higher priority = processes sooner TODO
        /* 
         * Available states are:
         * - hold: Event is being modified or held in some form, do not submit
         * - pending: Waiting to be submitted
         * - success: Already succeeded (event should be deleted in this case)
         * - idConflict: Event has already been processed by server (same as success)
         * - failure: Generic failure, allow user to manually retry
         * 
         * Other states can be provided and managed by subclasses
         */
    }

    toObj() {
        return {
            "type": this.type,
            "name": this.name,
            "data": this.data,
            "timeCreated": this.timeCreated,
            "id": this.id,
            "autoSubmit": this.autoSubmit,
            "status": this.status,
            "priority": this.priority
        }
    }

    randomId() {
        return Math.random().toString().substr(2);
    }

    submit(callback) {
        console.log("Please override this function.");
        callback({ "success": "true" });
    }
}

class OfflineEventPost extends OfflineEvent {
    constructor(obj) {
        obj.type = "OfflineEventPost";
        super(obj);

        // obj.data = {
        //     "formUrl": "form url",
        //     "formData": "form data"
        // }
    }

    submit(callback, force) {
        function finish(success) {
            if (callback) callback({
                "success": success
            });
            
            finishInputBlock();
        }

        if ((this.status == "success") && !force) return;

        if (!navigator.onLine) return;

        startInputBlock();
        $.post(
            this.data.formUrl,
            this.data.formData,
            (data, status) => {
                if (status == "success") {
                    this.response = {
                        data: data,
                        status: status
                    };
                    this.status = "success";
                    finish(true);
                } else {
                    this.status = "failure";
                    this.failures++;
                    finish(false);
                }
            }
        ).fail(() => {
            this.status = "failure";
            this.failures++;
            finish(false);
        });
    }
}

class OfflineEventQueue {
    constructor(name) {
        this.events = [];
        this.name = name || 'default';
        this.updateCallbacks = {};
        this.loadEvents();
    }

    runUpdateCallbacks(msg) {
        Object.keys(this.updateCallbacks).forEach((callbackId) => {
            let callbackObj = this.updateCallbacks[callbackId];
            callbackObj.callback(msg);
            if (callbackObj.once) this.removeUpdateCallback(callbackId);
        });
    }

    addUpdateCallback(callback, once) {
        let callbackId = parseInt(Math.random().toString().replace('.', '')); // lole
        this.updateCallbacks[callbackId] = {
            "callback": callback,
            "once": once
        };
        return callbackId;
    }

    removeUpdateCallback(id) {
        this.updateCallbacks[id] = undefined;
    }

    autoSubmit() {
        this.events.forEach((event, i) => {
            if (event.status == 'pending')
                return this.removeEventIndex(i);

            if (!event.autoSubmit) return;
            
            if (event.status == 'pending') {
                event.submit((result) => {
                    if (result.success) 
                        return this.removeEventIndex(i);
                    this.saveEvents();
                });
            }
        });

    }

    removeEvent(event) {
        this.removeEventIndex(this.events.indexOf(event));
    }

    getEventIndexById(id) {
        let indexFinal = -1;
        this.events.some((event, i) => {
            if (event.id == id) {
                indexFinal = i;
                return true;
            }
        });
        return indexFinal;
    }

    getEventById(id) {
        let eventFinal;
        this.events.some((event) => {
            if (event.id == id) {
                eventFinal = event;
                return true;
            }
        });
        return eventFinal;
    }

    removeEventId(id) {
        this.removeEventIndex(this.getEventIndexById(id));
    }
    
    removeEventIndex(index) {
        if (index <= -1) return;
        if (typeof index == 'undefined') return;
        this.events.splice(index, 1);
        this.saveEvents();
    }
    
    clearEvents() {
        this.events = [];
        this.saveEvents();
    }

    addEvent(event) {
        this.events.push(event);
        this.saveEvents();        
    }

    toArray() {
        let eventsArray = [];
        this.events.forEach((event) => {
            eventsArray.push(event.toObj());
        });
        return eventsArray;
    }

    saveEvents() {
        let key = `offlineEvents.${this.name}`;
        localStorage[key] = JSON.stringify(this.toArray());
        this.runUpdateCallbacks("save");
    }

    loadEvents() {
        let key = `offlineEvents.${this.name}`;
        let eventsString = localStorage[key];

        if ((typeof eventsString == 'undefined') || (eventsString == ''))
            return;

        let eventsArray = JSON.parse(eventsString);
        eventsArray.forEach((eventData) => {
            this.events.push(new OfflineEventPost(eventData)); // TODO
        });
        this.runUpdateCallbacks("load");        
    }
}

var offlineEventQueue;

$(() => {
    offlineEventQueue = new OfflineEventQueue();
});
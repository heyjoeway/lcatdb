let typeNames = {
    "values.depth": "Depth",
    "values.temperature": "Temperature",
    "timeCreated": "Time Created",
    "location.lat": "Latitude",
    "location.long": "Longitude",
    "location.alt": "Altitude"
};

Array.prototype.xor = function(other) {
    let newArray = [];
    this.forEach((val) => {
        if (!other.includes(val))
            newArray.push(val);
    });
    return newArray;
}

function isUndefined(val) {
    return typeof val == 'undefined';
}

function genUid(size = 32) {
    let uid = "";
    let charSet = "QWERTYUIOPASDFGHJKLZXCVBNM1234567890";
    for (let i = 0; i < size; i++) {
        uid += charSet[Math.round(Math.random() * (charSet.length - 1))];
    }
    return uid;
}

function jqValue($element, newVal) { 
    let propType = $element.prop('type');
    if (isUndefined(newVal)) {
        let propVal = $element.val();

        if (propType == 'radio') {
            if (!$element.prop('checked'))
                return undefined;
        } else if (propType == 'checkbox')
            propVal = $element.prop('checked');
        else if (propType == 'number') {
            if (($element.attr('step') % 1) == 0)
                propVal = parseInt(propVal);
            else
                propVal = parseFloat(propVal);
        }

        return propVal;
    } else {
        if (propType == 'radio') {
            $element.prop(
                'checked',
                $element.val() == newVal
            );
        } else if (propType == 'checkbox') {
            $element.prop('checked', newVal);
        } else $element.val(newVal);
    }
}

function setPropertyByPath(obj, path, val) {
    path.split('.').forEach((key, i, arr) => {
        if (i == arr.length - 1) {
            obj[key] = val;
            return;
        }

        if (typeof obj[key] == 'undefined')
            obj[key] = {};

        obj = obj[key];
    });
}

function getProps(selector, props) {
    let newProps = {};
    $(selector).each((i, element) => {
        let $element = $(element);
        let propType = $element.prop('type');
        let propVal = jqValue($element);

        if (typeof propVal == 'undefined') return;

        let propName = $element.prop('name');

        if (typeof propName == 'undefined') {
            console.log("ERROR: name is undefined");
            console.log($element);
            return;
        }

        let propPath = newProps;

        setPropertyByPath(newProps, propName, propVal);
    });

    $.extend(true, props, newProps);
    return newProps;
}

function getPropertyByPath(obj, path) {
    let error = path.split('.').some((key, i, arr) => {
        obj = obj[key];

        if (typeof obj == 'undefined') {
            console.log("ERROR: Couldn't find value.")
            console.log($element);
            return true;
        }

        return false;
    });

    if (!error) return obj;  
    return;
}

function setProps(selector, props) {
    $(selector).each((i, element) => {
        let $element = $(element);

        let propType = $element.prop('type');

        let propName = $element.prop('name');

        if (typeof propName == 'undefined') {
            console.log("ERROR: name is undefined");
            console.log($element);
            return;
        }

        let propVal = getPropertyByPath(props, propName)
        if (typeof propVal == "undefined") return;

        jqValue($element, propVal);
    });
}

class CallbackChannel {
    constructor() {
        this.callbacks = {};
        this.callbackCtr = 0;
    }

    add(callback) {
        this.callbacks[this.callbackCtr] = callback;
        return this.callbackCtr++;
    }

    remove(key) {
        delete this.callbacks[key];
    }

    run(status, data) {
        Object.keys(this.callbacks).forEach((key) => {
            this.callbacks[key](status, data);
        });
    }
}


class DataSet {
    defaultProps() {
        return {
            "time": {
                "enabled": false,
                "min": 0,
                "max": 0
            },
            "location": {
                "enabled": false,
                "lat": {
                    "min": -90,
                    "max": 90
                },
                "long": {
                    "min": -180,
                    "max": 180
                }
            },
            "users": {
                "limit": "all",
                "whitelist": []
            },
            "configurations": {
                "limit": "all",
                "whitelist": []
            },
            "misc": {
                "entries": 0
            }
        }
    }

    constructor(data) {
        data = data || {};

        this.name = data.name || "N/A";
        this.uid = data.uid || genUid();

        this.props = this.defaultProps();
        $.extend(
            true, // deep
            this.props, //target
            data.props
        );

        this.callbacks = new CallbackChannel();
    }

    toJSON() {
        return {
            "name": this.name,
            "uid": this.uid,
            "props": this.props
        };
    }

    toString() {
        return JSON.stringify(this.toJSON());
    }

    controlsToProps() {
        let newProps = getProps('.set-control', this.props);
        this.callbacks.run("DataSet.props");
    }

    propsToControls() {
        setProps('.set-control', this.props);

        $('.set-control_time').attr(
            'disabled',
            !this.props.time.enabled
        );

        $('.set-control_location').attr(
            'disabled',
            !this.props.location.enabled
        );
    }

    propsToQuery() {
        let filter = [];
        let query = {
            "filter": {
                "$and": filter
            }
        };
        let props = this.props;

        if (props.time.enabled) {
            let timeMax = new Date(props.time.max);
            let timeMin = new Date(props.time.min);

            if (timeMax < timeMin) {
                $.notify({
                    "message": `Error in "${this.name}": Invalid time range.`
                }, {
                    "type": 'error'
                });
                return;
            }
            filter.push({ 
                'timeCreated': {
                    "$lte": timeMax.getTime(),
                    "$gte": timeMin.getTime()
                }
            });
        }

        if (props.location.enabled) {
            filter.push({
                'location.lat': {
                    "$lte": parseFloat(props.location.lat.max),
                    "$gte": parseFloat(props.location.lat.min),
                }
            });

            filter.push({
                'location.long': {
                    "$lte": parseFloat(props.location.long.max),
                    "$gte": parseFloat(props.location.long.min),
                }
            });
        }

        if (props.users.limit != 'all') {
            if (props.users.limit == 'whitelist') {
                let or = [];
                props.users.whitelist.forEach((user) => {
                    or.push({
                        'creator': user
                    });
                });

                if (or.length > 0)
                    filter.push({
                        "$or": or
                    });
            } else {
                query['users'] = props.users.limit;
            }
        }

        if (props.configurations.limit != 'all') {
            if (props.configurations.limit == 'whitelist') {
                let or = [];                
                props.configurations.whitelist.forEach((user) => {
                    or.push({
                        'configuration': user
                    });
                });

                if (or.length > 0)
                    filter.push({
                        "$or": or
                    });
            }
        }

        if (props.misc.entries > 0) {
            query['pageSize'] = props.misc.entries;
            query['page'] = 1;
        }

        return query;
    }

    destroy() {
        this.callbacks.run("DataSet.destroy", {
            set: this
        });
    }
}

class DataSetManager {
    constructor() {
        this.sets = [];
        this.setCurrent = -1;
        this.nameCounter = 1;

        $('.set-control').change(() => {
            this.controlChange();
        });

        $('#new_set').click(() => {
            this.newSet();
        });

        $('#delete_set').click(() => {
            this.deleteSet();
        });

        $('#list_set').change(() => {
            let setId = parseInt($('#list_set').val());
            this.switchSet(setId);
        });

        this.setUidMap = {};
        this.callbacks = new CallbackChannel();
        this.load();
    }

    clear() {
        while (this.sets.length)
            this.removeSet();

        this.nameCounter = 0;
    }

    toJSON() {
        return {
            sets: this.sets.map(set => set.toJSON()),
            nameCounter: this.nameCounter,
            setCurrent: this.setCurrent
        }
    }

    fromJSON(jsonObj) {
        this.clear();
        jsonObj.sets.forEach((setData) => {
            this.addSet(new DataSet(setData));
        });
        this.switchSet(jsonObj.setCurrent);
        this.nameCounter = jsonObj.nameCounter || 0;
    }

    store() {
        localStorage["visualize.DataSetManager"] = JSON.stringify(this.toJSON());
    }

    load() {
        this.fromJSON(JSON.parse(
            localStorage["visualize.DataSetManager"] || "{}"
        ));
    }

    populateMenu() {
        let html = '';

        this.sets.forEach((set, i) => {
            let selected = (this.setCurrent == i) ? 'selected' : '';
            html += `<option value="${i}" ${selected}>${set.name}</option>`;
        });

        $("#list_set").prop('disabled', html == '');
        if (html == '')
            html = `<option value="" disabled selected hidden>No data sets created.</option>`;

        $("#list_set").html(html);
    }

    newSet() {
        let set = new DataSet({
            name: "Set " + (this.nameCounter++)
        });

        this.addSet(set);

        this.callbacks.run("DataSetManager.new");
        this.switchSet(this.sets.length - 1);

        this.store();
    }

    addSet(set) {
        set.callbacks.add(status => {
            this.callbacks.run(status);
        });
        this.sets.push(set);
        if (typeof set.uid != 'undefined')    
           this.setUidMap[set.uid] = set;
    }

    switchSet(i) {
        if (typeof i != 'undefined')
            this.setCurrent = i;
        
        this.setCurrent = Math.min(
            this.setCurrent,
            this.sets.length - 1
        );

        if (this.setCurrent == -1) {
            $('#section_properties').hide();
            $('#section_description').show();
        } else {
            $('#section_properties').show();
            $('#section_description').hide();
            this.sets[this.setCurrent].propsToControls();
        }

        this.populateMenu();
    }

    removeSet(i) {
        if (this.sets.length == 0) return;
    
        if (typeof i == 'undefined')
            i = this.setCurrent;
    
        let set = this.sets[i];
    
        if (typeof set.uid != 'undefined')
            delete this.setUidMap[set.uid];
        this.sets.splice(i, 1);
    
        set.destroy();
    
        if (this.setCurrent >= this.sets.length)
            this.setCurrent = this.sets.length - 1;
    }

    deleteSet(i) {
        this.removeSet(i);
        this.switchSet();
        this.store();
    }

    controlChange(e) {
        this.sets[this.setCurrent].controlsToProps();
        this.store();
    }

    getSetByUid(setUid) {
        return this.setUidMap[setUid];
    }
}

class Graph {
    defaultProps() {
        return {};
    }

    constructor(data) {
        if (typeof data != 'undefined')
            this.name = data.name;

        this.props = this.defaultProps();
        $.extend(
            true, // deep
            this.props, // target
            data.props // src
        );

        this.callbacks = new CallbackChannel();

        this.type = "none";

        this.sets = [];
        data.sets.forEach(set => this.addSet(set));
    }

    toJSON() {
        return {
            "props": this.props,
            "type": this.type,
            "sets": this.sets.map(set => set.uid),
            "name": this.name
        }
    }

    addSet(dataSet) {
        dataSet.callbacks.add((status, data) => {
            if (status == "DataSet.destroy")
                this.removeSet(data.set);
        });
        this.sets.push(dataSet);
    }

    getSetIndex(dataSet) {
        let index;
        this.sets.some((dataSetIn, i) => {
            if (dataSet === dataSetIn) {
                index = i;
                return true;
            }
        });
        return index;
    }

    removeSet(dataSet) {
        let i;
        if (typeof dataSet == 'number') i = dataSet;
        else i = this.getSetIndex(dataSet);

        this.sets.splice(i, 1);

        this.callbacks.run("Graph.removeSet");
    }

    propsToControls() {
        $('.graph_typeprefs').hide();
    }
  
    destroy() { }

    getData(callback, fields) {
        this.data = [];
        let setsLeft = this.sets.length + 1;

        let gotData = (data) => {
            if (data) this.data.push(data);
            setsLeft--;
            if (setsLeft == 0) callback(this.data);
        };

        gotData();

        this.sets.forEach((set) => {
            let query = set.propsToQuery();
            query.fields = fields;

            $.post(`${serverUrl}/api/readings`, query, (data, status) => {
                if (status == 'success') gotData(data);
            });
        });
    }

    createGraph() {
        let html = '';
        return html;
    }
}

class GraphMap extends Graph {
    static get typeName() { return "Map"; }

    defaultProps() {
        return { };
    }

    constructor(data) {
        super(data);
        this.type = "map";
    }

    propsToControls() {
        super.propsToControls();
        $('.graph_typeprefs#map').show();
    }

    getData(callback) {
        this.data = [];

        this.sets.forEach((set) => {
            let query = set.propsToQuery();
            this.data.push(query);
        });

        callback(this.data);
    }

    createGraph() {
        let queries = JSURL.stringify(this.data);
        let url ="./embed/map.html?queries=" + queries;
        let $element = $('<iframe></iframe>', {
            "class": "graph_map map-iframe",
            "src": url
        });
        return $element;
    }
}

class GraphQuery extends Graph {
    static get typeName() { return "Query"; }

    defaultProps() {
        return { };
    }

    constructor(data) {
        super(data);
        this.type = "query";
    }

    propsToControls() {
        super.propsToControls();
        $('.graph_typeprefs#query').show();
    }

    getData(callback) {
        this.data = [];

        this.sets.forEach((set) => {
            let query = set.propsToQuery();
            this.data.push(query);
        });

        callback(this.data);
    }

    createGraph() {
        let $element = $('<pre></pre>', {
            "class": "graph_filter",
            "html": "<code>" + JSON.stringify(this.data, null, '\t') + "</code>"
        });
        return $element;
    }
}

class GraphRaw extends Graph {
    static get typeName() { return "Raw"; }

    defaultProps() {
        return { };
    }

    constructor(data) {
        super(data);
        this.type = "raw";
    }

    propsToControls() {
        super.propsToControls();
        $('.graph_typeprefs#raw').show();
    }

    createGraph() {
        let $element = $('<pre></pre>', {
            "class": "graph_raw",
            "html": "<code>" + JSON.stringify(this.data, null, '\t') + "</code>"
        });
        return $element;
    }
}

class Graph2d extends Graph {
    static get typeName() { return "2-D Plot"; }

    defaultProps() {
        return {
            "x": {
                "var": "timeCreated"
            },
            "y": {
                "var": "values.temperature"
            }
        };
    }

    constructor(data) {
        super(data);
        this.type = "2d";
    }

    controlsToProps() {
        getProps('.graph-control-2d', this.props);
    }

    propsToControls() {
        super.propsToControls();
        $('.graph_typeprefs#2d').show();
        setProps('.graph-control-2d', this.props);
    }

    organizeData(dataRaw) {
        let dataOrganized = [];
        let props = this.props;

        dataRaw.forEach((setRaw, i) => {
            setRaw.forEach((readingRaw) => {
                let readingOrganized = {
                    "group": i
                };

                ['x', 'y'].forEach((axis) => {
                    let valueOrganized;

                    let valueVar = props[axis].var;
                    let isValue = valueVar.startsWith('values');
                    if (!isValue) {
                        valueOrganized = getPropertyByPath(readingRaw, valueVar);
                    } else {
                        let valueType = valueVar.split('.')[1];
                        readingRaw.values.some((value) => {
                            if (valueType == value.type) {
                                valueOrganized = value.data[valueType];
                                return true;
                            }
                            return false;
                        });
                    }

                    if (!isNaN(valueOrganized))
                        valueOrganized = parseFloat(valueOrganized);

                    readingOrganized[axis] = valueOrganized;
                });

                if (typeof readingOrganized.x == 'undefined') return;
                if (typeof readingOrganized.y == 'undefined') return;

                dataOrganized.push(readingOrganized);
            });
        });

        return dataOrganized;
    }

    getData(callback) {
        let props = this.props;
        let fields = {
            "values": 1
        };

        let dataSets = [];

        if (!props.x.var.startsWith('values'))
            fields[props.x.var] = 1;


        if (!props.y.var.startsWith('values'))
            fields[props.y.var] = 1;

        super.getData((dataRaw) => {
            this.data = this.organizeData(dataRaw);
            callback(this.data);
        }, fields);
    }

    createGraph() {
        let $element = $('<div></div>', {
            "width": 512,
            "height": 512
        });
        $('#output').html($element)
        let container = $element[0];
      
        let dataset = new vis.DataSet(this.data);
        let options = {
            "legend": true,
            "dataAxis": {
                "left": {
                    "title": {
                        "text": typeNames[this.props.y.var]
                    }
                }
            }
        };
        let graph2d = new vis.Graph2d(container, dataset, options);
    }
}

class Graph3d extends Graph {
    static get typeName() { return "3-D Plot"; }

    defaultProps() {
        return {
            "x": {
                "var": "location.lat"
            },
            "y": {
                "var": "location.long"
            },
            "z": {
                "var": "values.depth"
            },
            "style": {
                "var": "values.temperature"
            }
        };
    }

    constructor(data) {
        super(data);
        this.type = "3d";
    }

    controlsToProps() {
        getProps('.graph-control-3d', this.props);
    }

    propsToControls() {
        super.propsToControls();
        $('.graph_typeprefs#3d').show();
        setProps('.graph-control-3d', this.props);
    }

    organizeData(dataRaw) {
        let dataOrganized = [];
        let props = this.props;

        dataRaw.forEach((setRaw, i) => {
            setRaw.forEach((readingRaw) => {
                let readingOrganized = {
                    "group": i
                };

                ['x', 'y', 'z', 'style'].forEach((axis) => {
                    let valueOrganized;

                    let valueVar = props[axis].var;
                    let isValue = valueVar.startsWith('values');
                    if (!isValue) {
                        valueOrganized = getPropertyByPath(readingRaw, valueVar);
                    } else {
                        let valueType = valueVar.split('.')[1];
                        readingRaw.values.some((value) => {
                            if (valueType == value.type) {
                                valueOrganized = value.data[valueType];
                                if ((valueType == "depth") && (axis == 'z'))
                                    valueOrganized = -valueOrganized;
                                return true;
                            }
                            return false;
                        });
                    }

                    if (!isNaN(valueOrganized))
                        valueOrganized = parseFloat(valueOrganized);

                    readingOrganized[axis] = valueOrganized;
                });

                if (typeof readingOrganized.x == 'undefined') return;
                if (typeof readingOrganized.y == 'undefined') return;
                if (typeof readingOrganized.z == 'undefined') return;
                if (typeof readingOrganized.style == 'undefined') return;

                dataOrganized.push(readingOrganized);
            });
        });

        return dataOrganized;
    }

    getData(callback) {
        let props = this.props;
        let fields = {
            "values": 1
        };

        let dataSets = [];

        if (!props.x.var.startsWith('values'))
            fields[props.x.var] = 1;


        if (!props.y.var.startsWith('values'))
            fields[props.y.var] = 1;

        super.getData((dataRaw) => {
            this.data = this.organizeData(dataRaw);
            callback(this.data);
        }, fields);
    }

    createGraph() {
        let $element = $('<div></div>');
        $('#output').html($element)
        let container = $element[0];
      
        let dataset = new vis.DataSet(this.data);
        let options = {
            "width": '512px',
            "height": '512px',
            "xLabel": typeNames[this.props.x.var],
            "yLabel": typeNames[this.props.y.var],
            "zLabel": typeNames[this.props.z.var],
            "legendLabel": typeNames[this.props.style.var],
            "showLegend": true,
            "style": 'dot-color'
            // "dataAxis": {
            //     "left": {
            //         "title": {
            //             "text": typeNames[this.props.y.var]
            //         }
            //     }
            // }
        };
        if (this.props.z.var == "values.depth")
            options.zValueLabel = function(z) {
                return -z;
            };


        let graph3d = new vis.Graph3d(container, dataset, options);

        $($element.children()[0]).addClass('visualize-graph-3d');
    }
}

const graphTypeDict = {
    "2d": Graph2d,
    "3d": Graph3d,
    "map": GraphMap,
    "raw": GraphRaw,
    "query": GraphQuery
}

class GraphManager {
    constructor(dataSetManager) {
        this.graphs = [];
        this.graphCurrent = -1;
        this.nameCounter = 1;
        this.dataSetManager = dataSetManager;
        this.dataSetManager.callbacks.add(this.callback.bind(this));

        this.setsAvailable = [];

        $('.graph-control').change(() => {
            this.controlChange();
        });

        $('.new_graph').click((e) => {
            this.newGraph($(e.target).data('type'));
        });

        $('#delete_graph').click(() => {
            this.deleteGraph();
        });

        $('#list_graph').change(() => {
            let setId = parseInt($('#list_graph').val());
            this.switchGraph(setId);
        });

        $('#addset_graph').click(() => {
            this.addSet();
        });

        $('#removeset_graph').click(() => {
            this.removeSets();
        });

        $('#create_graph').click(() => {
            this.createGraph();
        });

        this.load();
    }

    callback(status) {
        this.updateSets();
    }

    clear() {
        while (this.graphs.length)
            this.removeGraph();
    }

    populateMenu() {
        let html = '';

        this.graphs.forEach((graph, i) => {
            let selected = (this.graphCurrent == i) ? 'selected' : '';
            html += `<option value="${i}" ${selected}>${graph.name}</option>`;
        });

        $("#list_graph").prop('disabled', html == '');
        if (html == '')
            html = `<option value="" disabled selected hidden>No graphs created.</option>`;


        $("#list_graph").html(html);
    }

    newGraph(type) {
        let graphType = graphTypeDict[type];

        this.addGraph(new graphType({
            "name": `Graph ${this.nameCounter++} (${graphType.typeName})`
        }));
        this.switchGraph(this.graphs.length - 1);

        this.store();
    }

    addGraph(graph) {
        this.graphs.push(graph);
        graph.callbacks.add(status => {
            if (status == "Graph.removeSet") {
                this.updateSets();
                this.store();
            }
        });
    }

    switchGraph(i) {
        if (typeof i != 'undefined')
            this.graphCurrent = i;
        
        this.graphCurrent = Math.min(
            this.graphCurrent,
            this.graphs.length - 1
        );

        if (this.graphCurrent == -1) {
            $('#section_graph_properties').hide();
            $('#section_graph_description').show();
            $('#create_graph').attr('disabled', 'true');
        } else {
            $('#section_graph_description').hide();
            $('#section_graph_properties').show();
            $('#create_graph').removeAttr('disabled');
            this.graphs[this.graphCurrent].propsToControls();
        }

        this.populateMenu();
        this.updateSets();
    }

    removeGraph(i) {
        if (this.graphs.length == 0)
            return;
    
        if (typeof i == 'undefined')
            i = this.graphCurrent;
        
        this.graphs[i].destroy();
        this.graphs.splice(i, 1);
    
        if (this.graphCurrent >= this.graphs.length)
            this.graphCurrent = this.graphs.length - 1;

    }

    deleteGraph(i) {
        this.removeGraph(i);
        this.switchGraph();
        this.store();
    }

    updateSets() {
        if (this.graphCurrent == -1) return;

        this.setsCurrent = this.graphs[this.graphCurrent].sets;
        this.setsAvailable = dataSetManager.sets.xor(this.setsCurrent);

        let availableHtml = '';

        this.setsAvailable.forEach((set, i) => {
            let selected = (0 == i) ? 'selected' : '';
            availableHtml += `<option value="${i}" ${selected}>${set.name}</option>`;
        });

        $("#list_setsgraphavail").html(availableHtml);

        let currentHtml = '';

        this.setsCurrent.forEach((set, i) => {
            currentHtml += `<option value="${i}">${set.name}</option>`;
        });

        $("#list_setsgraphcur").html(currentHtml);
    }

    addSet() {
        let i = parseInt($("#list_setsgraphavail").val());
        if (isNaN(i)) return;
        let set = this.setsAvailable[i];
        this.graphs[this.graphCurrent].addSet(set);

        this.updateSets();

        this.store();
    }

    removeSets() {
        $("#list_setsgraphcur").val().forEach((val) => {
            let i = parseInt(val);
            let set = this.setsCurrent[i];
            this.graphs[this.graphCurrent].removeSet(set);
        });

        this.updateSets();

        this.store();
    }

    createGraph() {
        let graphCurrent = this.graphs[this.graphCurrent];
        graphCurrent.getData(() => {
            $('#output').html(graphCurrent.createGraph());
        });
    }

    controlChange(e) {
        this.graphs[this.graphCurrent].controlsToProps();
        this.store();
    }

    toJSON() {
        return {
            graphs: this.graphs.map(graph => graph.toJSON()),
            nameCounter: this.nameCounter,
            graphCurrent: this.graphCurrent
        };
    }

    fromJSON(jsonObj) {
        this.clear();

        jsonObj.graphs.forEach(graph => {
            let graphType = graphTypeDict[graph.type];

            this.addGraph(new graphType({
                "props": graph.props,
                "name": graph.name,
                "sets": graph.sets.map(
                    setUid => this.dataSetManager.getSetByUid(setUid)
                )
            }));
        });

        this.switchGraph(jsonObj.graphCurrent);
        this.nameCounter = jsonObj.nameCounter;
    }

    store() {
        localStorage["visualize.GraphManager"] = JSON.stringify(this.toJSON());
    }

    load() {
        // try {
            this.fromJSON(JSON.parse(
                localStorage["visualize.GraphManager"] || "{}"
            ));
        // } catch (e) { }
    }
}

let dataSetManager, graphManager;

$(() => {
    updateNavbar();

    dataSetManager = new DataSetManager();
    graphManager = new GraphManager(dataSetManager);

    if(!Modernizr.inputtypes['datetime-local']) {
        $('input[type=datetime-local]').datetimepicker({
            "showMeridian": true,
            "format": "yyyy-mm-ddThh:ii",
            "startView": 2,
            "minView": 0,
            "todayBtn": true,
            "todayHighlight": true
        });
    }

    $('input[name="time.enabled"]').change(function() {
        $('.set-control_time').attr(
            'disabled',
            !this.checked
        );
    });

    $('input[name="location.enabled"]').change(function() {
        $('.set-control_location').attr(
            'disabled',
            !this.checked
        );
    });

});
let typeNames = {
    "depth": "Depth",
    "temperature": "Temperature"
}

Array.prototype.xor = function(other) {
    let newArray = [];
    this.forEach((val) => {
        if (!other.includes(val))
            newArray.push(val);
    });
    return newArray;
}

function isUndefined(val) {
    return typeof val == 'undefined';
}

function jqValue($element, newVal) {
    let propType = $element.prop('type');
    if (isUndefined(newVal)) {
        let propVal = $element.val();

        if (propType == 'radio') {
            if (!$element.prop('checked'))
                return undefined;
        } else if (propType == 'checkbox')
            propVal = $element.prop('checked');
        else if (propType == 'number') {
            if (($element.attr('step') % 1) == 0)
                propVal = parseInt(propVal);
            else
                propVal = parseFloat(propVal);
        }

        return propVal;
    } else {
        if (propType == 'radio') {
            $element.prop(
                'checked',
                $element.val() == newVal
            );
        } else if (propType == 'checkbox')
            $element.prop('checked', newVal);
        else
            $element.val(newVal);
    }
}

function setPropertyByPath(obj, path, val) {
    path.split('.').forEach((key, i, arr) => {
        if (i == arr.length - 1) {
            obj[key] = val;
            return;
        }

        if (typeof obj[key] == 'undefined')
            obj[key] = {};

        obj = obj[key];
    });
}

function getProps(selector, props) {
    let newProps = {};
    $(selector).each((i, element) => {
        let $element = $(element);
        let propType = $element.prop('type');
        let propVal = jqValue($element);

        if (typeof propVal == 'undefined') return;

        let propName = $element.prop('name');

        if (typeof propName == 'undefined') {
            console.log("ERROR: name is undefined");
            console.log($element);
            return;
        }

        let propPath = newProps;

        setPropertyByPath(newProps, propName, propVal);
    });

    $.extend(true, props, newProps);
    return newProps;
}

function getPropertyByPath(obj, path) {
    let error = path.split('.').some((key, i, arr) => {
        obj = obj[key];

        if (typeof obj == 'undefined') {
            console.log("ERROR: Couldn't find value.")
            console.log($element);
            return true;
        }

        return false;
    });

    if (!error) return obj;  
    return;
}

function setProps(selector, props) {
    $(selector).each((i, element) => {
        let $element = $(element);

        let propType = $element.prop('type');

        let propName = $element.prop('name');

        if (typeof propName == 'undefined') {
            console.log("ERROR: name is undefined");
            console.log($element);
            return;
        }

        let propVal = getPropertyByPath(props, propName)
        if (!propVal) return;

        jqValue($element, propVal);
    });
}

class DataSet {
    defaultProps() {
        return {
            "time": {
                "enabled": false,
                "min": 0,
                "max": 0
            },
            "location": {
                "enabled": false,
                "lat": {
                    "min": -90,
                    "max": 90
                },
                "long": {
                    "min": -180,
                    "max": 180
                }
            },
            "users": {
                "limit": "all",
                "whitelist": []
            },
            "configurations": {
                "limit": "all",
                "whitelist": []
            },
            "misc": {
                "entries": 0
            }
        }
    }

    constructor(data) {
        if (typeof data == 'string')
            data = { "name": data };
        
        if (typeof data != 'undefined')
            this.name = data.name;

        this.props = $.extend(
            true, // deep
            {}, //target
            this.defaultProps(),
            data.props
        );

        this.callbacks = {};
        this.callbackCtr = 0;
    }

    addCallback(callback) {
        this.callbacks[this.callbackCtr] = callback;
        return this.callbackCtr++;
    }

    removeCallback(key) {
        delete this.callbacks[key];
    }

    runCallbacks(status) {
        Object.keys(this.callbacks).forEach((key) => {
            this.callbacks[key](this, status);
        });
    }

    toJSON() {
        return {
            "name": this.name,
            "props": this.props
        };

    }

    toString() {
        return JSON.stringify(this.toJSON());
    }

    controlsToProps() {
        let newProps = getProps('.set-control', this.props);
        this.runCallbacks("props");
    }

    propsToControls() {
        setProps('.set-control', this.props);

        $('.set-control_time').attr(
            'disabled',
            !this.props.time.enabled
        );

        $('.set-control_location').attr(
            'disabled',
            !this.props.location.enabled
        );
    }

    propsToQuery() {
        let filter = [];
        let query = {
            "filter": {
                "$and": filter
            }
        };
        let props = this.props;

        if (props.time.enabled) {
            let timeMax = new Date(props.time.max);
            let timeMin = new Date(props.time.min);

            if (timeMax < timeMin) {
                $.notify({
                    "message": `Error in "${this.name}": Invalid time range.`
                }, {
                    "type": 'error'
                });
                return;
            }
            filter.push({ 
                'timeCreated': {
                    "$lte": timeMax.getTime(),
                    "$gte": timeMin.getTime()
                }
            });
        }

        if (props.location.enabled) {
            filter.push({
                'location.lat': {
                    "$lte": parseFloat(props.location.lat.max),
                    "$gte": parseFloat(props.location.lat.min),
                }
            });

            filter.push({
                'location.long': {
                    "$lte": parseFloat(props.location.long.max),
                    "$gte": parseFloat(props.location.long.min),
                }
            });
        }

        if (props.users.limit != 'all') {
            if (props.users.limit == 'whitelist') {
                let or = [];
                props.users.whitelist.forEach((user) => {
                    or.push({
                        'creator': user
                    });
                });

                if (or.length > 0)
                    filter.push({
                        "$or": or
                    });
            } else {
                query['users'] = props.users.limit;
            }
        }

        if (props.configurations.limit != 'all') {
            if (props.configurations.limit == 'whitelist') {
                let or = [];                
                props.configurations.whitelist.forEach((user) => {
                    or.push({
                        'configuration': user
                    });
                });

                if (or.length > 0)
                    filter.push({
                        "$or": or
                    });
            }
        }

        if (props.misc.entries > 0) {
            query['pageSize'] = props.misc.entries;
            query['page'] = 1;
        }

        console.log(query);
        return query;
    }

    destroy() {
        this.runCallbacks("destroy");
    }
}

class DataSetManager {
    constructor() {
        this.sets = [];
        this.setCurrent = -1;
        this.nameCounter = 1;

        $('.set-control').change(() => {
            this.controlChange();
        });

        $('#new_set').click(() => {
            this.newSet();
        });

        $('#delete_set').click(() => {
            this.deleteSet();
        });

        $('#list_set').change(() => {
            let setId = parseInt($('#list_set').val());
            this.switchSet(setId);
        });

        this.load();

        this.callbacks = {};
        this.callbackCtr = 0;
    }

    addCallback(callback) {
        this.callbacks[this.callbackCtr] = callback;
        return this.callbackCtr++;
    }

    removeCallback(key) {
        delete this.callbacks[key];
    }

    runCallbacks(status) {
        Object.keys(this.callbacks).forEach((key) => {
            this.callbacks[key](this, status);
        });
    }

    clear() {
        while (this.sets.length) {
            this.deleteSet();
        }
    }

    store() {
        let setData = [];
        this.sets.forEach((set) => {
            setData.push(set.toJSON());
        });

        localStorage["visualize.dataSets"] = JSON.stringify(setData);
    }

    load() {
        this.clear();
        let setData;
        try {
            setData = JSON.parse(localStorage["visualize.dataSets"]);
        } catch(e) { 
            return;
        }
    
        setData.forEach((data) => {
            this.sets.push(new DataSet(data));
        });

        this.switchSet(0);
    }

    populateMenu() {
        let html = '';

        this.sets.forEach((set, i) => {
            let selected = (this.setCurrent == i) ? 'selected' : '';
            html += `<option value="${i}" ${selected}>${set.name}</option>`;
        });

        $("#list_set").html(html);
    }

    newSet() {
        let set = new DataSet(
            "Set " + (this.nameCounter++)
        );

        set.addCallback(this.runCallbacks.bind(this));

        this.sets.push(set);
        this.switchSet(this.sets.length - 1);

        this.runCallbacks("new");
    }

    switchSet(i) {
        if (typeof i != 'undefined')
            this.setCurrent = i;
        
        this.setCurrent = Math.min(
            this.setCurrent,
            this.sets.length - 1
        );

        if (this.setCurrent == -1) {
            $('#section_properties').hide();
            $('#view_graphs').hide();
            $('#section_description').show();
        } else {
            $('#section_properties').show();
            $('#view_graphs').show();
            $('#section_description').hide();
            this.sets[this.setCurrent].propsToControls();
        }

        this.populateMenu();

    }

    deleteSet(i) {
        if (this.sets.length == 0)
            return;

        if (typeof i == 'undefined')
            i = this.setCurrent;
        
        this.sets[i].destroy();
        // delete this.sets[i];
        this.sets.splice(i, 1);

        if (this.setCurrent >= this.sets.length)
            this.setCurrent = this.sets.length - 1;

        this.switchSet();
    }

    controlChange(e) {
        this.sets[this.setCurrent].controlsToProps();
        this.store();
    }
}

class Graph {
    defaultProps() {
        return {};
    }

    constructor(data) {
        if (typeof data == 'string')
            data = { "name": data };
        
        if (typeof data != 'undefined')
            this.name = data.name;

        this.props = $.extend(
            true, // deep
            {}, //target
            this.defaultProps(),
            data.props
        );

        this.type = "None";
        this.sets = [];
    }

    addSet(dataSet) {
        dataSet.addCallback((set, status) => {
            if (status == "destroy") this.removeSet(set);
        });
        this.sets.push(dataSet);
    }

    getSetID(dataSet) {
        let id;
        this.sets.some((dataSetIn, i) => {
            if (dataSet === dataSetIn) {
                id = i;
                return true;
            }
            return false;
        });
        return id;
    }

    removeSet(dataSet) {
        let i;
        if (typeof dataSet == 'number') i = dataSet;
        else i = this.getSetID(dataSet);

        this.sets.splice(i, 1);
    }

    propsToControls() {
        $('.graph_typeprefs').hide();
    }
  
    destroy() { }

    getData(callback, fields) {
        this.data = [];
        let setsLeft = this.sets.length + 1;

        let gotData = (data) => {
            if (data) this.data.push(data);
            setsLeft--;
            if (setsLeft == 0) callback(this.data);
        }

        gotData();

        this.sets.forEach((set) => {
            let query = set.propsToQuery();
            query.fields = fields;

            $.post('/api/readings', query, (data, status) => {
                if (status == 'success') gotData(data);
            });
        });
    }

    createGraph() {
        let html = '';
        return html;
    }

}

class GraphMap extends Graph {
    static get typeName() { return "Map"; }

    defaultProps() {
        return { };
    }

    constructor(data) {
        super(data);
        this.type = "map";
    }

    propsToControls() {
        super.propsToControls();
        $('.graph_typeprefs#map').show();
    }

    getData(callback) {
        this.data = [];

        this.sets.forEach((set) => {
            let query = set.propsToQuery();
            this.data.push(query);
        });

        callback(this.data);
    }

    createGraph() {
        let queries = JSURL.stringify(this.data);
        let url ="/embed/map.html?queries=" + queries;
        let $element = $('<iframe></iframe>', {
            "class": "graph_map map-iframe",
            "src": url
        });
        return $element;
    }
}

class GraphQuery extends Graph {
    static get typeName() { return "Query"; }

    defaultProps() {
        return { };
    }

    constructor(data) {
        super(data);
        this.type = "query";
    }

    propsToControls() {
        super.propsToControls();
        $('.graph_typeprefs#query').show();
    }

    getData(callback) {
        this.data = [];

        this.sets.forEach((set) => {
            let query = set.propsToQuery();
            this.data.push(query);
        });

        callback(this.data);
    }

    createGraph() {
        let $element = $('<pre></pre>', {
            "class": "graph_filter",
            "html": "<code>" + JSON.stringify(this.data, null, '\t') + "</code>"
        });
        return $element;
    }
}

class GraphRaw extends Graph {
    static get typeName() { return "Raw"; }

    defaultProps() {
        return { };
    }

    constructor(data) {
        super(data);
        this.type = "raw";
    }

    propsToControls() {
        super.propsToControls();
        $('.graph_typeprefs#raw').show();
    }

    createGraph() {
        let $element = $('<pre></pre>', {
            "class": "graph_raw",
            "html": "<code>" + JSON.stringify(this.data, null, '\t') + "</code>"
        });
        return $element;
    }
}

class Graph2d extends Graph {
    static get typeName() { return "2-D Plot"; }

    defaultProps() {
        return {
            "x": {
                "var": "timeCreated"
            },
            "y": {
                "var": "values.temperature"
            }
        };
    }

    constructor(data) {
        super(data);
        this.type = "2d";
    }

    controlsToProps() {
        getProps('.graph-control-2d', this.props);
    }

    propsToControls() {
        super.propsToControls();
        $('.graph_typeprefs#2d').show();
        setProps('.graph-control-2d', this.props);
    }

    organizeData(dataRaw) {
        let dataOrganized = [];
        let props = this.props;

        dataRaw.forEach((setRaw, i) => {
            let set = {
                "label": "Set " + i,
                "color": "#FF0000",
                "borderColor": "#FF0000",
                "fill": false,
                "data": []
            };

            setRaw.forEach((reading) => {
                let data = {};

                ['x', 'y'].forEach((axis) => {
                    let valueVar = props[axis].var;
                    let isValue = valueVar.startsWith('values');
                    if (!isValue)
                        data[axis] = getPropertyByPath(reading, valueVar);
                    else {
                        let valueType = valueVar.split('.')[1];
                        reading.values.some((value) => {
                            if (valueType == value.type) {
                                data[axis] = value.data[valueType];
                                return true;
                            }
                            return false;
                        });
                    }
                });

                let dataKeys = Object.keys(data);
                if (dataKeys.includes('x') && dataKeys.includes('y'))
                    set.data.push(data);
            });
            dataOrganized.push(set);
        });
        return dataOrganized;
    }

    getData(callback) {
        let props = this.props;
        let fields = {
            "values": 1
        };

        let dataSets = [];

        if (!props.x.var.startsWith('values'))
            fields[props.x.var] = 1;

        if (!props.y.var.startsWith('values'))
            fields[props.y.var] = 1;

        super.getData((dataRaw) => {
            this.data = this.organizeData(dataRaw);
            callback(this.data);
        }, fields);
    }

    createGraph() {
        let props = this.props;
        let config = {
            "type": "line",
            "data": {
                "datasets": this.data
            },
            "options": {
                "responsive": true,
                "scales": {
                    "xAxes": [{
                        "display": true,
                        "scaleLabel": {
                            "display": true,
                            "labelString": props.x.var
                        }
                    }],
                    "yAxes": [{
                        "display": true,
                        "scaleLabel": {
                            "display": true,
                            "labelString": props.y.var
                        }
                    }]
                }
            }
        };

        let $element = $('<canvas></canvas>', {
            "width": 512,
            "height": 512
        });

        $('#output').html($element)

        this.chartCurrent = new Chart($element, config);

        return;
    }
}

const graphTypeDict = {
    "2d": Graph2d,
    "map": GraphMap,
    "raw": GraphRaw,
    "query": GraphQuery
}

class GraphManager {
    constructor(dataSetManager) {
        this.graphs = [];
        this.graphCurrent = -1;
        this.nameCounter = 1;
        this.dataSetManager = dataSetManager;
        this.dataSetManager.addCallback(this.callback.bind(this));

        this.setsAvailable = [];

        $('.graph-control').change(() => {
            this.controlChange();
        });

        $('.new_graph').click((e) => {
            this.newGraph($(e.target).data('type'));
        });

        $('#delete_graph').click(() => {
            this.deleteGraph();
        });

        $('#list_graph').change(() => {
            let setId = parseInt($('#list_graph').val());
            this.switchGraph(setId);
        });

        $('#addset_graph').click(() => {
            this.addSet();
        });

        $('#removeset_graph').click(() => {
            this.removeSets();
        });

        $('#create_graph').click(() => {
            this.createGraph();
        });

        // this.load();
    }

    callback(set, status) {
        console.log(status);
        this.updateSets();
    }

    clear() {
        while (this.graphs.length) {
            this.deleteGraph();
        }
    }

    populateMenu() {
        let html = '';

        this.graphs.forEach((graph, i) => {
            let selected = (this.graphCurrent == i) ? 'selected' : '';
            html += `<option value="${i}" ${selected}>${graph.name}</option>`;
        });

        $("#list_graph").html(html);
    }

    newGraph(type) {
        let graphType = graphTypeDict[type];

        this.graphs.push(new graphType(
            `Graph ${this.nameCounter++} (${graphType.typeName})`
        ));
        this.switchGraph(this.graphs.length - 1);
    }

    switchGraph(i) {
        if (typeof i != 'undefined')
            this.graphCurrent = i;
        
        this.graphCurrent = Math.min(
            this.graphCurrent,
            this.graphs.length - 1
        );

        if (this.graphCurrent == -1) {
            $('#section_graph_properties').hide();
            $('#section_graph_description').show();
            $('#create_graph').attr('disabled', 'true');
        } else {
            $('#section_graph_description').hide();
            $('#section_graph_properties').show();
            $('#create_graph').removeAttr('disabled');
            this.graphs[this.graphCurrent].propsToControls();
        }

        this.populateMenu();
        this.updateSets();
    }

    deleteGraph(i) {
        if (this.graphs.length == 0)
            return;

        if (typeof i == 'undefined')
            i = this.graphCurrent;
        
        this.graphs[i].destroy();
        // delete this.graphs[i];
        this.graphs.splice(i, 1);

        if (this.graphCurrent >= this.graphs.length)
            this.graphCurrent = this.graphs.length - 1;

        this.switchGraph();
    }

    updateSets() {
        if (this.graphCurrent == -1) return;

        this.setsCurrent = this.graphs[this.graphCurrent].sets;
        this.setsAvailable = dataSetManager.sets.xor(this.setsCurrent);

        let availableHtml = '';

        this.setsAvailable.forEach((set, i) => {
            let selected = (0 == i) ? 'selected' : '';
            availableHtml += `<option value="${i}" ${selected}>${set.name}</option>`;
        });

        $("#list_setsgraphavail").html(availableHtml);

        let currentHtml = '';

        this.setsCurrent.forEach((set, i) => {
            currentHtml += `<option value="${i}">${set.name}</option>`;
        });

        $("#list_setsgraphcur").html(currentHtml);
    }

    addSet() {
        let i = parseInt($("#list_setsgraphavail").val());
        let set = this.setsAvailable[i];
        this.graphs[this.graphCurrent].addSet(set);

        this.updateSets();
    }

    removeSets() {
        $("#list_setsgraphcur").val().forEach((val) => {
            let i = parseInt(val);
            let set = this.setsCurrent[i];
            this.graphs[this.graphCurrent].removeSet(set);
        });

        this.updateSets();
    }

    createGraph() {
        let graphCurrent = this.graphs[this.graphCurrent];
        graphCurrent.getData(() => {
            $('#output').html(graphCurrent.createGraph());
        });
    }

    controlChange(e) {
        this.graphs[this.graphCurrent].controlsToProps();
        // this.store();
    }
}

let dataSetManager, graphManager;

$(() => {
    updateNavbar();

    dataSetManager = new DataSetManager();
    graphManager = new GraphManager(dataSetManager);

    if(!Modernizr.inputtypes['datetime-local']) {
        $('input[type=datetime-local]').datetimepicker({
            "showMeridian": true,
            "format": "yyyy-mm-ddThh:ii",
            "startView": 2,
            "minView": 0,
            "todayBtn": true,
            "todayHighlight": true
        });
    }

    $('input[name="time.enabled"]').change(function() {
        $('.set-control_time').attr(
            'disabled',
            !this.checked
        );
    });

    $('input[name="location.enabled"]').change(function() {
        $('.set-control_location').attr(
            'disabled',
            !this.checked
        );
    });

});